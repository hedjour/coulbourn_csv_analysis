#' Get lickometer data
#' 
#' This function takes a raw export file from Graphic State and returns a tidy data set ready for analysis.
#'
#' @param df a dataframe corresponding to a .txt file generated by a raw-data export from Graphic State
#' @param numSession number of sessions contained in export file
#' @param CS optional label. Defaults to 'Tone'.
#' @return dataframe ready for analysis
#' @author Jason Shumake
#' @details 
#' The getLickData function takes a data frame or table corresponding to a .txt file generated by
#' a raw-data export from Graphic State. 
#' 
#' The function presumes that the lickometer device is registered as
#' input A1 and that protocol identities exist as follows in the GraphicState database:
#' 
#'  Protocol 1: Habituation
#'  
#'  Protocol 2: Acquisition
#'  
#'  Protocol 3: Single Retrieval Trial
#'  
#'  Protocol 4: Extinction w/17 trials
#'  
#'  Protocol 5: Extinction w/18 trials
#'  
#'  Protocol 6: LTM
#'  
#' The function also presumes the following state logic for all of these protocols:
#' 
#'  State 1 == the ITI
#'  
#'  State 2 == the pre-CS interval (in our programs, the 20 sec preceding each CS when the DVR is turned on)
#'  
#'  State 3 == the CS
#'  
#'  State 4 == the US (only exists in the acquisition protocol)
#'    
#' The function performs the following operations:
#' 
#'  1. Eliminates uninformative variables.
#' 
#'  2. Assigns correct session and trial numbers to each row of data.
#' 
#'  3. If applicable, assigns a 'CS' variable to indicate if the licks are from the ITI (labeled 'Context')
#'    or the specific stimulus (labeled with the 2nd parameter of the function or 'Tone' by default).  
#'    
#'  4. Calculates lick time for each subject aggregated by session, CS, and trial. 
#' 
#'  5. Replaces the protocol number with a descriptive label (acquisition )
#' 
#' @export
#' @importFrom plyr rbind.fill


getLickData = function(df,numSession,CS='Tone')
{
  df = subset(df,Time!=0,select = c(3,4,5,7,8,9,12))
  vars = names(df)
  ##rename 'Current State' and 'A1 -' variables to 'State' and 'Lick'
  vars[6:7] = c('State','Lick')
  setnames(df,vars)
  ## Graphic State increments the session number every time a new protocol is
  ## loaded. But we want the session number to reflect the number of times a
  ## particular subject has encountered the protocol. This is a simple trick
  ## to get the session count to reset to 1:
  df$Session = as.numeric(as.factor(df$Session))
  ## If you run all of your subjects consecutively through the same
  ## protocol before switching to a different protocol, this number accurately
  ## reflects our concept of session. However, if you are switching back and
  ## forth between protocols (for example, between the retrieval trial program
  ## and the extinction program), the session number may increment before all
  ## subjects have been run through that session. The following algorithm
  ## detects whether this has happened, and, if there is a regular pattern
  ## (the number of detected sessions is a multiple of the number of expected
  ## session provided by the numSession paramater), issues a warning and
  ## automatically renumbers the sessions correctly. In the event a pattern
  ## cannot be detected, an error will be issued and you must manually correct
  ## the file before proceeding.
  maxSession = max(df$Session)
  if (maxSession %% numSession != 0)
    stop ("Detected more sessions than expected. Verify the numSession parameter
          and inspect your data for session labeling errors.")
  if (maxSession > numSession)
  {
    warning ("Detected more sessions than expected. Automatically correcting
             session labels. Verify that new labels are correct.")
    sessionNum = rep(1:numSession, each=maxSession/numSession)
    for (x in 1:maxSession) df$Session[df$Session == x] = sessionNum[x]
  }
  if (df$Protocol[1] == 1) #data is from habituation session
  {
    subjects = split(df,list(df$Subject,df$Session),drop=T)
    df = rbind.fill(lapply(subjects,lick_time))
    remove(subjects)
    df = aggregate(Drink.Time ~ Subject+Station+Protocol+Session, data=df, mean)
    df$CS = NA
    df$Trial = NA
    df = df[c('Subject','Station','Protocol','Session','Trial','CS','Drink.Time')]
  } else #data is from a learning/memory session
    {
    df$CS[df$State==1] = 'Context_ITI'
    df$CS[df$State==2] = 'Context_Pre'
    df$CS[df$State==3] = CS
    df$Trial = 0
    subjects = split(df,list(df$Subject,df$Protocol,df$Session),drop=T)
    df = unsplit(lapply(subjects,label_trials),
                 list(df$Subject,df$Protocol,df$Session))
    subjects = split(df,list(df$Subject,df$Protocol,df$Session,df$Trial,df$CS),drop=T)
    df = rbind.fill(lapply(subjects,lick_time))
    remove(subjects)
    df = aggregate(Drink.Time ~ Subject+Station+Protocol+Session+Trial+CS, data=df, mean)
    }
  
  df$Protocol[df$Protocol == 1] = 'Hab'
  df$Protocol[df$Protocol == 2] = 'Acq'
  df$Protocol[df$Protocol %in% c(3,4,5)] = 'Ext'
  df$Protocol[df$Protocol == 6] = 'LTM'
  
  return(df)
}

