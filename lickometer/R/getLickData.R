#' Get lickometer data
#' 
#' This function takes a raw export file from Graphic State and returns a tidy data set ready for analysis.
#'
#' @param df a dataframe corresponding to a .txt file generated by a raw-data export from Graphic State
#' @param CS optional label. Defaults to 'Tone'.
#' @return dataframe ready for analysis
#' @author Jason Shumake
#' @details 
#' The clean_data function takes a data frame or table corresponding to a .txt file generated by
#' a raw-data export from Graphic State. 
#' 
#' The function presumes that the lickometer device is registered as
#' input A1 and that protocol identities exist as follows in the GraphicState database:
#' 
#'  Protocol 1: Habituation
#'  
#'  Protocol 2: Acquisition
#'  
#'  Protocol 3: Single Retrieval Trial
#'  
#'  Protocol 4: Extinction w/17 trials
#'  
#'  Protocol 5: Extinction w/18 trials
#'  
#'  Protocol 6: LTM
#'  
#' The function also presumes the following state logic for all of these protocols:
#' 
#'  State 1 == the ITI
#'  
#'  State 2 == the pre-CS interval (in our programs, the 20 sec preceding each CS when the DVR is turned on)
#'  
#'  State 3 == the CS
#'  
#'  State 4 == the US (only exists in the acquisition protocol)
#'    
#' The function performs the following operations:
#' 
#'  1. Eliminates uninformative variables.
#' 
#'  2. Assigns correct session and trial numbers to each row of data.
#' 
#'  3. If applicable, assigns a 'CS' variable to indicate if the licks are from the ITI (labeled 'Context')
#'    or the specific stimulus (labeled with the 2nd parameter of the function or 'Tone' by default).  
#'    
#'  4. Calculates lick time for each subject aggregated by session, CS, and trial. 
#' 
#'  5. Replaces the protocol number with a descriptive label (acquisition )
#' 
#' @export
#' @importFrom plyr rbind.fill


getLickData = function(df,CS='Tone')
{
  #source('label_trials.R')
  #source('lick_time.R')
  df = subset(df,Time!=0,select = c(3,4,5,7,8,9,12))
  vars = names(df)
  ##rename 'Current State' and 'A1 -' variables to 'State' and 'Lick'
  vars[6:7] = c('State','Lick')
  setnames(df,vars)
  df$Session = as.numeric(as.factor(df$Session))
  ##not sure why extra session labels were generated for retrieval session,
  ##but this fixes the problem
  if (df$Protocol[1] == 3) 
  {
    df$Session[df$Session==2] = 1
    df$Session[df$Session==3 | df$Session==4] = 2
  }
  
  if (df$Protocol[1] == 1) #data is from habituation session
  {
    subjects = split(df,list(df$Subject,df$Session),drop=T)
    df = rbind.fill(lapply(subjects,lick_time))
    remove(subjects)
    df = aggregate(Drink.Time ~ Subject+Station+Protocol+Session, data=df, mean)
    df$CS = NA
    df$Trial = NA
    df = df[c('Subject','Station','Protocol','Session','Trial','CS','Drink.Time')]
  } else #data is from a learning/memory session
    {
    df$CS = 'Context'
    df$CS[df$State==3] = CS
    df$Trial = 0
    subjects = split(df,list(df$Subject,df$Protocol,df$Session),drop=T)
    df = unsplit(lapply(subjects,label_trials),
                 list(df$Subject,df$Protocol,df$Session))
    subjects = split(df,list(df$Subject,df$Protocol,df$Session,df$Trial,df$CS),drop=T)
    df = rbind.fill(lapply(subjects,lick_time))
    remove(subjects)
    df = aggregate(Drink.Time ~ Subject+Station+Protocol+Session+Trial+CS, data=df, mean)
    }
  
  df$Protocol[df$Protocol == 1] = 'Habituation'
  df$Protocol[df$Protocol == 2] = 'Acquisition'
  df$Protocol[df$Protocol %in% c(3,4,5)] = 'Extinction'
  df$Protocol[df$Protocol == 6] = 'LTM'
  
  return(df)
}

